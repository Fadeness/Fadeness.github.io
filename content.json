{"meta":{"title":"Fringe","subtitle":"where pain covers","description":"Broken Arrows in the Dark","author":"Fadeness","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-05-12T11:49:21.000Z","updated":"2018-05-12T12:53:03.002Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-12T11:52:06.000Z","updated":"2018-05-12T12:52:48.344Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-05-12T11:52:15.000Z","updated":"2018-05-12T12:52:54.735Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"ChromeDebuggerLaunchSetting","slug":"ChromeDebuggerLaunchSetting","date":"2018-07-18T10:33:00.000Z","updated":"2018-07-18T10:49:59.909Z","comments":true,"path":"2018/07/18/ChromeDebuggerLaunchSetting/","link":"","permalink":"http://yoursite.com/2018/07/18/ChromeDebuggerLaunchSetting/","excerpt":"Chrome debugger launch setting","text":"Chrome debugger launch setting 12345678910111213141516171819202122&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"chrome\", \"request\": \"launch\", \"name\": \"live-server Chrome debugger attachment\", \"url\": \"http://127.0.0.1:5500\", // same port of live-server \"webRoot\": \"$&#123;workspaceFolder&#125;\", \"file\": \"$&#123;workspaceFolder&#125;/index.html\" &#125;,&#123; \"name\": \"Launch index.html (disable sourcemaps)\", \"type\": \"chrome\", \"request\": \"launch\", \"sourceMaps\": false, \"file\": \"$&#123;workspaceFolder&#125;/index.html\" &#125; ]&#125;","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://yoursite.com/tags/Visual-Studio-Code/"}]},{"title":"二叉树","slug":"二叉树","date":"2018-07-17T10:52:30.000Z","updated":"2018-07-17T11:15:20.141Z","comments":true,"path":"2018/07/17/二叉树/","link":"","permalink":"http://yoursite.com/2018/07/17/二叉树/","excerpt":"存放二叉树相关代码","text":"存放二叉树相关代码 二叉树定义1234struct BinaryTreeNode &#123; int l, r; // l stands for left child, r stands for right child int val; // val stands for the value of this node&#125; 二叉树插入操作123456789101112131415161718192021222324252627282930313233int currentNodeNumber = 1;void Insert(int root, int curNodeValue) // root stands for the father of this node&#123; if(curNodeValue &gt; Node[root].val)&#123; if(Node[root].r == 0)&#123; Node[root].r = currentNodeNumber; Node[Now].val = curNodeValue; return; &#125; else Insert(Node[root].r, curNodeValue); &#125; else&#123; if(Node[root].l == 0)&#123; Node[root].l = currentNodeNumber; Node[Now].val = curNodeValue; return; &#125; else Insert(Node[root].l, curNodeValue); &#125;&#125;int main()&#123; int root; cin &gt;&gt; root; // read root of the tree for(int i = 1; i &lt; NodeNums; i++) &#123; currentNodeNumber++; int currentNodeValue; cin &gt;&gt; currentNodeValue; Insert(1, currentNodeValue); &#125;&#125; 前序遍历123456789101112void PreOrder(int x)&#123; printf(\"%d \", Node[x].val); int lChild = Node[x].l; int rChild = Node[x].r; if(Node[lChild].val != 0) &#123; PreOrder(lChild); &#125; if(Node[rChild].val != 0) &#123; PreOrder(rChild); &#125;&#125; 中序遍历123456789101112void MiddleOrder(int x)&#123; int lChild = Node[x].l; int rChild = Node[x].r; if(Node[lChild].val != 0) &#123; MiddleOrder(lChild); &#125; printf(\"%d \", Node[x].val); if(Node[rChild].val != 0) &#123; MiddleOrder(rChild); &#125;&#125; 后序遍历123456789101112void ReverseOrder(int x)&#123; int lChild = Node[x].l; int rChild = Node[x].r; if(Node[lChild].val != 0) &#123; ReverseOrder(lChild); &#125; if(Node[rChild].val != 0) &#123; ReverseOrder(rChild); &#125; printf(\"%d \", Node[x].val);&#125;","categories":[],"tags":[]},{"title":"hexo操作简记","slug":"hexo操作简记","date":"2018-07-17T10:30:24.000Z","updated":"2018-07-17T10:48:42.308Z","comments":true,"path":"2018/07/17/hexo操作简记/","link":"","permalink":"http://yoursite.com/2018/07/17/hexo操作简记/","excerpt":"","text":"创建新文章 —— hexo n title 生成静态文件 —— hexo g 部署到github —— hexo d (暂记到此)","categories":[{"name":"文档","slug":"文档","permalink":"http://yoursite.com/categories/文档/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]},{"title":"html滚动交互(一)","slug":"html滚动交互(一)","date":"2018-05-18T07:50:38.000Z","updated":"2018-05-19T11:27:47.653Z","comments":true,"path":"2018/05/18/html滚动交互(一)/","link":"","permalink":"http://yoursite.com/2018/05/18/html滚动交互(一)/","excerpt":"在平时上网过程中,我们有时会见到这样一种网页 —— 随着你鼠标的滚动,会出现很有趣的交互效果,比如这个想要实现这种效果,一种方法就是做到对页面滚动事件的监听.通过监听获得的滚动条位置来决定相应的交互效果","text":"在平时上网过程中,我们有时会见到这样一种网页 —— 随着你鼠标的滚动,会出现很有趣的交互效果,比如这个想要实现这种效果,一种方法就是做到对页面滚动事件的监听.通过监听获得的滚动条位置来决定相应的交互效果 利用scroll进行滚动监听用jquery为JavaScript的”scroll”事件绑定一个处理函数，或者触发元素上的该事件。1$(selector).scroll(function) 当selector所选的元素发生了滚动事件,就会执行funciton方法当一个元素的内容没有产生垂直方向的滚动条，那么无论如何都不会执行function。 scrollTop Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。利用jquery的选择器,用法如下 123var offset_top = $(selector).scrollTop(); //获得选择元素的scrollTop值$(selector).scrollTop(200); //设定选择元素的scrollTop值 实战掌握了上述内容之后,就可以开始尝试一下简单的滚动交互设计 设计效果创建一个相对于窗口定位的元素,当滚动到距离页面头部250px时,给该元素添加active类;当滚动到距离页面头部小于250px时,从该元素中移除active类;当滚动到距离页面头部350px时,从该元素中移除active类 html部分123&lt;body&gt; &lt;div class=\"header\"&gt;&lt;/div&gt;&lt;/body&gt; css部分1234567891011121314body&#123; margin: 0; height: 1000px;&#125;.header&#123; position: fixed; width: 100%; height: 200px; background-color: black; transition: background-color 200ms linear; //添加过渡动画效果&#125;.active&#123; background-color: gray;&#125; javascript部分12345678910111213&lt;script src='js/jquery.min.js'&gt;&lt;/script&gt;&lt;script&gt; var offset_top; $(window).scroll(function() &#123; offset_top = $(window).scrollTop(); //每次scroll事件都更新offset_top的值,保证当前offset_top反映的是正确的值 if(offset_top &gt;= 250 &amp;&amp; offset_top &lt; 350)&#123; $('.header').addClass('active'); &#125;else&#123; $('.header').removeClass('active'); &#125; &#125;);&lt;/script&gt; 结语我们利用scroll和scrollTop实现了简单的滚动交互,这种方法也足以实现比较复杂的滚动交互.滚动交互体验好不好的关键在于设计,至于实现方法都大同小异.想要做出精妙的并且体验良好的滚动交互设计,是要依靠自己天马行空的想象力和合理的网页设计逻辑来实现的.","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"并查集","slug":"并查集","date":"2018-05-16T12:00:47.000Z","updated":"2018-05-20T05:07:40.411Z","comments":true,"path":"2018/05/16/并查集/","link":"","permalink":"http://yoursite.com/2018/05/16/并查集/","excerpt":"前文本文参考自并查集-百度百科,agatelee’s 带权并查集 什么是并查集并查集是一种树形的数据结构,用于处理一些不相交集合的合并及查询问题. 并查集可以看作一个森林,森林中的每一颗树都代表着一个集合.","text":"前文本文参考自并查集-百度百科,agatelee’s 带权并查集 什么是并查集并查集是一种树形的数据结构,用于处理一些不相交集合的合并及查询问题. 并查集可以看作一个森林,森林中的每一颗树都代表着一个集合. 并查集的主要操作初始化 123void init()&#123; for(int i = 1; i &lt;= N; i++) fa[i] = i; //将每个元素的父亲指向自己,&#125; 查询 123int find(int u)&#123; //返回u的祖先,也就是查询u所在的集合 return fa[u] = fa[u] == u ? u : find(fa[u]); //路径压缩&#125; 合并 123456void unin(int u, int v)&#123; //将u,v所在的树合并,也就是合并u,v所在的两个集合 int fu = find(u); int fv = find(v); if(fu == fv) return; fa[fv] = fu;&#125; 启发式合并优化按rank启发式合并：为了避免退化，对于每个集合维护一个rank值，每次将较小的合并到较大的，相同时则rank=rank+1u1234567891011void unin(int u, int v)&#123; int fu = find(u); int fv = find(v); if(rank[u] &lt; rank[v]) fa[u] = v; else &#123; fa[v] = u; if(rank[u] == rank[v]) rank[u]++; &#125;&#125; 经典例题poj1611题目翻译学校里有许多社团,同一个社团里的学生彼此之间来往密切,一个学生可能加入了多个社团.一旦一个社团里一名学生被认定为病毒携带嫌疑人,该社团其他成员都会被认定为病毒携带嫌疑人.学校发现当知道一名同学为嫌疑人时,要确定所有嫌疑人是一件很困难的事,所以你的工作就是写一个程序来找出所有的嫌疑人. 输入输入文件包含多组数据.每组数据第一行有n,m两个正整数,n代表学生总数,m代表社团的总数.其中 0 &lt; n &lt;= 30000 , 0 &lt;= m &lt;= 500.每一个学生都有一个从0到n-1的单独编号,并且对于所有数据编号为0的学生是病毒携带嫌疑人.接下来又m行,每行代表一个社团.每行第一个数k代表该组人数,接下来k个数代表该社团的学生. n = 0且m = 0的数据代表输入文件结束,并且不需要处理. 输出对每一组数据,输出一行病毒携带嫌疑人总人数 样例输入 100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 样例输出 411 题解根据题目意思,只需要对同一社团的人执行合并操作,完成后对于除0外的所有学生i,如果i和0拥有共同的祖先,那么嫌疑人总人数加一,所得的总人数即该题答案. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define Maxn 30005int N,M;int fa[Maxn];int find(int u)&#123; if(fa[u] != u) &#123; fa[u] = find(fa[u]); &#125; return(fa[u]);&#125;void unin(int u,int v)&#123; int fau = find(u); int fav = find(v); if(fau == fav) return; fa[fav] = fau;&#125;int main()&#123; while(cin &gt;&gt; N &gt;&gt; M) &#123; if(N == 0 &amp;&amp; M == 0) break; for(int i = 0; i &lt; N; i++) fa[i] = i; for(int i = 1; i &lt;= M; i++) &#123; int k,x1; cin &gt;&gt; k &gt;&gt; x1; for(int j = 1; j &lt; k; j++)&#123; int x; cin &gt;&gt; x; unin(x1,x); &#125; &#125; int ans = 1; for(int i=1;i&lt;N;i++) if(find(i) == find(0)) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"}]},{"title":"ScrollMagic中文文档(暂停更新,暑假恢复)","slug":"ScrollMagic中文文档","date":"2018-05-12T06:58:26.000Z","updated":"2018-05-15T07:13:47.984Z","comments":true,"path":"2018/05/12/ScrollMagic中文文档/","link":"","permalink":"http://yoursite.com/2018/05/12/ScrollMagic中文文档/","excerpt":"一个提供神奇的滚动交互的javascript库 ScrollMagic能够帮助你非常简单地对用户当前的滚动位置作出响应如果你想实现以下操作，对你来说这将是最合适的扩展库 基于滚动位置的动画 - 无论是触发一个动画或者将它同步到滚动条的移动(比如禁止回滚控制) 从特定的滚动位置开始固定一个元素 - 无论是一直固定还是只固定一段有限滚动进度(黏着元素) 基于滚动位置来切换元素的CSS类的开关 毫不费力地将视差效果添加到你的网站 创建一个无限滚动的页面(ajax加载额外的内容) 在特定的滚动位置添加回调,或者当滚动通过一个特定的部分时,传递一个进度参数 查看演示页面 , 浏览样例或者阅读文档来开始","text":"一个提供神奇的滚动交互的javascript库 ScrollMagic能够帮助你非常简单地对用户当前的滚动位置作出响应如果你想实现以下操作，对你来说这将是最合适的扩展库 基于滚动位置的动画 - 无论是触发一个动画或者将它同步到滚动条的移动(比如禁止回滚控制) 从特定的滚动位置开始固定一个元素 - 无论是一直固定还是只固定一段有限滚动进度(黏着元素) 基于滚动位置来切换元素的CSS类的开关 毫不费力地将视差效果添加到你的网站 创建一个无限滚动的页面(ajax加载额外的内容) 在特定的滚动位置添加回调,或者当滚动通过一个特定的部分时,传递一个进度参数 查看演示页面 , 浏览样例或者阅读文档来开始 关于库ScrollMagic是一个滚动交互库 是由John Polacek编写的Superscrollorama的基础上的完全改写一个基于插件的架构提供了易于定制和扩展的功能 为了实现动画,ScrollMagic能够使用多个框架.由于其稳定性和丰富的特性,推荐的解决方案是Greensock Animation Platform(GSAP).更轻量级的选择VelocityJS框架同样也被支持.另外可以实现自定义扩展或者可以完全不用框架，仅靠CSS和类切换来实现动画. ScrollMagic是在以下原则下开发的: 优化的性能 轻量级(压缩后仅6KB) 灵活性和可扩展性 移动端兼容性 事件管理 对响应式页面设计的支持 面向对象编程和对象链接","categories":[{"name":"文档","slug":"文档","permalink":"http://yoursite.com/categories/文档/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"},{"name":"文档","slug":"文档","permalink":"http://yoursite.com/tags/文档/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-05-12T03:57:01.000Z","updated":"2018-05-12T06:08:04.505Z","comments":true,"path":"2018/05/12/Hello-World/","link":"","permalink":"http://yoursite.com/2018/05/12/Hello-World/","excerpt":"","text":"&emsp;&emsp; 写作缘由 说明","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/文章/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yoursite.com/tags/杂记/"}]}]}
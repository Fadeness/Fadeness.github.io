{"meta":{"title":"Fringe","subtitle":"where pain covers","description":"Broken Arrows in the Dark","author":"Fadeness","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-05-12T11:49:21.000Z","updated":"2018-05-12T12:53:03.002Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-12T11:52:06.000Z","updated":"2018-05-12T12:52:48.344Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-05-12T11:52:15.000Z","updated":"2018-05-12T12:52:54.735Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"并查集","slug":"并查集","date":"2018-05-16T12:00:47.000Z","updated":"2018-05-17T22:56:36.860Z","comments":true,"path":"2018/05/16/并查集/","link":"","permalink":"http://yoursite.com/2018/05/16/并查集/","excerpt":"什么是并查集并查集是一种树形的数据结构,用于处理一些不相交集合的合并及查询问题. 并查集可以看作一个森林,森林中的每一颗树都代表着一个集合.","text":"什么是并查集并查集是一种树形的数据结构,用于处理一些不相交集合的合并及查询问题. 并查集可以看作一个森林,森林中的每一颗树都代表着一个集合. 并查集的主要操作初始化 123void init()&#123; //将每个元素的父亲指向自己, for(int i = 1; i &lt;= N; i++) fa[i] = i;&#125; 查询 123int find(int v)&#123; //返回v的祖先 return fa[v] = fa[v] == v ? v : find(fa[v]); //路径压缩&#125; 合并 123456void unin(int u, int v)&#123; //将u,v所在的树合并 int fu = find(u); int fv = find(v); if(fu == fv) return; fa[fv] = fu;&#125; 经典例题poj1611题目翻译学校里有许多社团,同一个社团里的学生彼此之间来往密切,一个学生可能加入了多个社团.一旦一个社团里一名学生被认定为病毒携带嫌疑人,该社团其他成员都会被认定为病毒携带嫌疑人.学校发现当知道一名同学为嫌疑人时,要确定所有嫌疑人是一件很困难的事,所以你的工作就是写一个程序来找出所有的嫌疑人. 输入输入文件包含多组数据.每组数据第一行有n,m两个正整数,n代表学生总数,m代表社团的总数.其中 0 &lt; n &lt;= 30000 , 0 &lt;= m &lt;= 500.每一个学生都有一个从0到n-1的单独编号,并且对于所有数据编号为0的学生是病毒携带嫌疑人.接下来又m行,每行代表一个社团.每行第一个数k代表该组人数,接下来k个数代表该社团的学生. n = 0且m = 0的数据代表输入文件结束,并且不需要处理. 输出对每一组数据,输出一行病毒携带嫌疑人总人数 样例输入 100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 样例输出 411 题解根据题目意思,只需要对同一社团的人执行合并操作,完成后对于除0外的所有学生i,如果i和0拥有共同的祖先,那么嫌疑人总人数加一,所得的总人数即该题答案. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define Maxn 30005int N,M;int fa[Maxn];int find(int u)&#123; if(fa[u] != u) &#123; fa[u] = find(fa[u]); &#125; return(fa[u]);&#125;void unin(int u,int v)&#123; int fau = find(u); int fav = find(v); if(fau == fav) return; fa[fav] = fau;&#125;int main()&#123; while(cin &gt;&gt; N &gt;&gt; M) &#123; if(N == 0 &amp;&amp; M == 0) break; for(int i = 0; i &lt; N; i++) fa[i] = i; for(int i = 1; i &lt;= M; i++) &#123; int k,x1; cin &gt;&gt; k &gt;&gt; x1; for(int j = 1; j &lt; k; j++)&#123; int x; cin &gt;&gt; x; unin(x1,x); &#125; &#125; int ans = 1; for(int i=1;i&lt;N;i++) if(find(i) == find(0)) ans++; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"}]},{"title":"ScrollMagic中文文档(暂停更新,暑假恢复)","slug":"ScrollMagic中文文档","date":"2018-05-12T06:58:26.000Z","updated":"2018-05-15T07:13:47.984Z","comments":true,"path":"2018/05/12/ScrollMagic中文文档/","link":"","permalink":"http://yoursite.com/2018/05/12/ScrollMagic中文文档/","excerpt":"一个提供神奇的滚动交互的javascript库 ScrollMagic能够帮助你非常简单地对用户当前的滚动位置作出响应如果你想实现以下操作，对你来说这将是最合适的扩展库 基于滚动位置的动画 - 无论是触发一个动画或者将它同步到滚动条的移动(比如禁止回滚控制) 从特定的滚动位置开始固定一个元素 - 无论是一直固定还是只固定一段有限滚动进度(黏着元素) 基于滚动位置来切换元素的CSS类的开关 毫不费力地将视差效果添加到你的网站 创建一个无限滚动的页面(ajax加载额外的内容) 在特定的滚动位置添加回调,或者当滚动通过一个特定的部分时,传递一个进度参数 查看演示页面 , 浏览样例或者阅读文档来开始","text":"一个提供神奇的滚动交互的javascript库 ScrollMagic能够帮助你非常简单地对用户当前的滚动位置作出响应如果你想实现以下操作，对你来说这将是最合适的扩展库 基于滚动位置的动画 - 无论是触发一个动画或者将它同步到滚动条的移动(比如禁止回滚控制) 从特定的滚动位置开始固定一个元素 - 无论是一直固定还是只固定一段有限滚动进度(黏着元素) 基于滚动位置来切换元素的CSS类的开关 毫不费力地将视差效果添加到你的网站 创建一个无限滚动的页面(ajax加载额外的内容) 在特定的滚动位置添加回调,或者当滚动通过一个特定的部分时,传递一个进度参数 查看演示页面 , 浏览样例或者阅读文档来开始 关于库ScrollMagic是一个滚动交互库 是由John Polacek编写的Superscrollorama的基础上的完全改写一个基于插件的架构提供了易于定制和扩展的功能 为了实现动画,ScrollMagic能够使用多个框架.由于其稳定性和丰富的特性,推荐的解决方案是Greensock Animation Platform(GSAP).更轻量级的选择VelocityJS框架同样也被支持.另外可以实现自定义扩展或者可以完全不用框架，仅靠CSS和类切换来实现动画. ScrollMagic是在以下原则下开发的: 优化的性能 轻量级(压缩后仅6KB) 灵活性和可扩展性 移动端兼容性 事件管理 对响应式页面设计的支持 面向对象编程和对象链接","categories":[{"name":"文档","slug":"文档","permalink":"http://yoursite.com/categories/文档/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"},{"name":"文档","slug":"文档","permalink":"http://yoursite.com/tags/文档/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Hello World","slug":"Hello-World","date":"2018-05-12T03:57:01.000Z","updated":"2018-05-12T06:08:04.505Z","comments":true,"path":"2018/05/12/Hello-World/","link":"","permalink":"http://yoursite.com/2018/05/12/Hello-World/","excerpt":"","text":"&emsp;&emsp; 写作缘由 说明","categories":[{"name":"文章","slug":"文章","permalink":"http://yoursite.com/categories/文章/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yoursite.com/tags/杂记/"}]}]}